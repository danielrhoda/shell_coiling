# RAUP SHELL COILING APP
# Raup Coiling Equations

library(geomorph)
library(Morpho)
library(rgl)
library(Rvcg)
library(geometry)
library(alphashape3d)
library(spdep)
library(LearnGeom)
library(mixtools)
library(colorBlindness) ; col.pal <- colorRampPalette(Blue2DarkRed18Steps)
library(shinyWidgets) ; library(shinydashboard) ; library(shinyjs)
library(bslib)
library(prodlim)



# defining functions I'm using
#######
# ResampleShell takes a shell array (aperture lm# x 3 (dimensions) x steps) and resamples the shell to make landmarks (vertices) equally spaced
ResampleShell <- function(array, steps){
  s1 <- array(data=NA,dim=c(dim(array)[3],3,dim(array)[1]))
  for(i in 1:dim(array)[3]){
  for(j in 1:dim(array)[1]){
  s1[i,,j] <- array[j,,i]
    }}

  s2 <- array(data = NA, dim=c(steps, 3, dim(s1)[3]))
  for(i in 1:dim(s1)[3]){
  s2[,,i] <- digit.curves(s1[1,,i],curve = s1[,,i], nPoints = steps-2, closed = FALSE)
  }

  s3 <- array(data=NA,dim=c(dim(s2)[3],3,dim(s2)[1]))
  for(i in 1:dim(s2)[3]){
  for(j in 1:dim(s2)[1]){
  s3[i,,j] <- s2[j,,i]
  }}
  return(s3)
}

#### RaupCoil takes parameters and creates landmarks representing the shape of a shell
RaupCoil <- function(s, w, t = 0, di = 0.05, degrees = 5, turns = 0.5, EqualSpace = NULL, sinistral = FALSE, snug = FALSE){
  ap <- s
  if(sinistral){w <- w^-1}

  if(snug){
    di <- (1 + (1+t^2)^0.5 + (1 - (1+t^2)^0.5)*w)/(1 - (1+t^2)^0.5 + (1 + (1+t^2)^0.5)*w)
  }


  map1 <- mean(ap[,1])
  map2 <- mean(ap[,2])
  map3 <- mean(ap[,3])
for(i in 1:dim(ap)[1]){
  ap[i,1] <- ap[i,1]-map1
  ap[i,2] <- ap[i,2]-map2
  ap[i,3] <- ap[i,3]-map3
}

  di <- -di
  maxX <- max(ap[,1])
  minX <- min(ap[,1])
  diff <- maxX - minX
  ap1 <- ap/diff

ap1[,1] <- ap1[,1] - (min(ap1[,1]) + di)

ap1[,3] <- ap1[,3] + (0.33 * (max(ap1[,3])-min(ap1[,3])))

ya <- max(ap1[,3])-min(ap1[,3])
rc <- mean(ap1[,1])

theta <- seq(from = 0, to = turns * 2 * pi,by = (pi * degrees)/180)
shellarry <- array(dim=c(dim(ap)[1],3,length(theta)))

for(j in 1:length(theta)){
#  w <- w * (1+(w1*j))
#  t <- t * (1+(t1*j))
  r <- c()
  k <- c()
  z <- c()
  for(i in 1:length(ap[,1])){
r[i] <- ap1[i,1] * (w^(theta[j]/(2*pi)))
k[i] <- ap1[i,2] * (w^(theta[j]/(2*pi)))
z[i] <- ap1[i,3] * (w^(theta[j]/(2*pi))) +  ya*rc*t*((w^(theta[j]/(2*pi)))-1)

shellarry[i,,j] <- c(r[i]*cos(theta[j]),r[i]*sin(theta[j])+k[i],z[i])
}
}
if(sinistral){shellarry <- shellarry[,,rev(1:dim(shellarry)[3])]}

if(is.null(EqualSpace)){
return(shellarry)}
else{
  shellarry <- ResampleShell(array = shellarry, steps = EqualSpace)
return(shellarry)}

}

# plots the points generated by RaupCoil
PlotRaupShellPoints <- function(shell,col=1,pal=NULL,rad=1){
if(!is.null(pal)){colvec <- make.color.vec(1:dim(shell)[3],dim(shell)[3],pallette = pal)}
for(i in 1:dim(shell)[3]){
  col <- colvec[i]
  lines3d(rbind(shell[,,i],shell[1,,i]),radius=rad,col=col)
}}

# changes a shell array into a matrix of the landmark coordinates
compress.shell <- function(shell){
shell.mat <- matrix(data = 0,ncol=3)
for(i in 1:dim(shell)[3]){
  if(i == 1){shell.mat <- shell[,,i]}else{
  shell.mat <- rbind(shell.mat,shell[,,i])}
  }
return(shell.mat)
} # or... do.call(rbind, shell)

# rescales a shell matrix to centroid size
rescale.shell <- function(x){
  y <- x/cSize(x)
  return(y)}

# make a function that inputs an 'aperture matrix' (with the 0 y value) and rotates it by some angle
rotate.aperture <- function(ap, angle){
lm <- ap
lm1 <- Rotation(lm[,c(1,3)],angle*pi/180)
ap <- matrix(data = NA, nrow=dim(ap)[1], ncol=3)
ap[,1] <- lm1[,1]
ap[,2] <- 0
ap[,3] <- lm1[,2]
return(ap)
} #

# tilt.ap - tilts the aperture about an axis
# used by bivalves to make sure that their whorls don't overlap
tilt.ap <- function(ap, angle, axis = "x"){
  if(axis == "x"){
    rotmat <- matrix(c(1,0,0,
              0,cos(angle),-sin(angle),
              0,sin(angle),cos(angle)),3,3)
  }
  if(axis == "y"){
    rotmat <- matrix(c(cos(angle),0,sin(angle),
                         0,1,0,
                         -sin(angle),0,cos(angle)),3,3)

  }
  if(axis == "z"){
    rotmat <- matrix(c(cos(angle),-sin(angle),0,
                         sin(angle),cos(angle),0,
                         0,0,1),3,3)

  }
  angle <- deg2rad(angle)
  ap <- ap %*% rotmat
}

# euc.dist calculates distance between two 3D coords
euc.dist <- function(a, b) sqrt(sum((a - b) ^ 2))

# given an aperture, this function finds the endpoints of the line that defines a centered rotation axis normal to the aperture
find.rot.axis <- function(ap){
  c <- centroid1(ap)
  p1 <- ap[1,]
  p2 <- ap[round((dim(ap)[1]/2)+1),]
  p3 <- ap[round((dim(ap)[1]/4)+1),]
  p4 <- ap[round((dim(ap)[1]*(3/4))+1),]
  l1 <- c(p2[1]+p1[1],p2[2]+p1[2],p2[3]+p1[3])
  l2 <- c(p4[1]+p3[1],p4[2]+p3[2],p4[3]+p3[3])
  z <- crossProduct(l1,l2)
  pt1 <- c
  pt2 <- c+z
  return(list(pt1=pt1,pt2=pt2))
}

# this function rotates an aperture that isn't necessarily centered at the origin or is tilted
rotate.tilted.aperture <- function(ap,theta){
   theta <- theta*(pi/180)
   pts <- find.rot.axis(ap)
  ap.rot <- rotaxis3d(x = ap, pt1=pts$pt1, pt2 = pts$pt2, theta = theta)
  return(ap.rot)
}

# takes a vector and scales and returns a color palette accordingly
make.color.vec <- function(x, n, pallette, rev = F){
x1 <- cut(as.numeric(x),breaks=n)
if(!rev){idcolor<-pallette(n)}else{id.color<-rev(pallette(n))}
x.cols <- 1:length(x1)
for(i in 1:length(x.cols)){x.cols[[i]] <- idcolor[as.numeric(x1[i])]}
names(x.cols) <- names(x)
return(x.cols)
}

deg2rad <- function(x){return(x * pi/180)}

#######


# I'm taking this out because I don't want to have all the tools to make the mesh (from the points from RaupCoil) inside server, so I'm pulling the code out here and wrapping it into a function
      make.mesh.from.shell <- function(input.shell){
        Npts <- 25
        Ngrowthlines <- dim(input.shell)[3] # # of growth lines
        Nq <- (Npts * (Ngrowthlines - 1))
        eg <- as.data.frame(expand.grid(1:Npts, 1:(Ngrowthlines-1)))


        quad.mat <- matrix(0,ncol = Nq,nrow = 4)
        for(i in 1:(Ngrowthlines-1)){
            for(j in 1:Npts)
          quad.mat[,row.match(c(j,i),eg)] <- c((j+((i-1)*Npts)),((j+1)+((i-1)*Npts)),((j+1)+(i*Npts)),(j+(i*Npts)))
        }
        quad.mat <- quad.mat[,-Nq]

        compshell <- compress.shell(input.shell)
        comprmesh <- updateNormals(mesh3d(compshell,quads = quad.mat[,-1225]))
        comprmesh
        }


#####

light <- bs_theme(primary = "#1e90ff")
dark <- bs_theme(bg = "#3D3D3D", fg = "#FFFFFF", primary = "#1e90ff")


ui <- dashboardPage(
  #theme = light,
  dashboardHeader(title="Shell Coiling"),


  dashboardSidebar(

#     switchInput("dark_mode",onLabel = "Light", offLabel = "Dark"),
      switchInput("uncoil",onLabel = "dextral", offLabel = "sinistral"),
      fluidRow(style = "height:30px;"),
      actionButton("snail", "preset gastropod", width = "80%"),
      actionButton("snail2", "random gastropod", width = "80%"),
      fluidRow(style = "height:30px;"),
      actionButton("clam", "preset pelycopod", width = "80%"),
      actionButton("clam2", "random pelycopod", width = "80%"),
      fluidRow(style = "height:30px;"),
      actionButton("ammonite", "preset ammonoid", width = "80%"),
      actionButton("ammonite2", "random ammonoid", width = "80%")

  ),


  dashboardBody(

    fluidRow(
        tabBox(
            width = "100%",
            # The id lets us use input$tabset1 on the server to find the current tab
            id = "tabset1", height = "auto",
            tabPanel("Shell Coiler",

              fluidRow(
                box(rglwidgetOutput("plot", width = 'auto', height = "400px"), width = 12,
                    title = "Your theroretical shell based on input parameters:", status = "primary")),
              fluidRow(
                column(6,
                sliderInput(inputId = "s1", label = "S - eccentricity",
                            min = 0, max = 1, value = 0.3, step = 0.05, width = '100%'),
                sliderInput(inputId = "s2", label = "S - rotation",
                            min = -180, max = 180, value = 0, step = 1, width = '100%')),
                column(6,
                sliderInput(inputId = "w", label = "log10(W) (whorl expansion rate)",
                            min = 0, max = 5, value = 0.3, step = 0.05, width = '100%'),
                sliderInput(inputId = "t", label = "T (translation rate)",
                            min = -5, max = 5, value = 2.2, step = 0.1, width = '100%'))
              ),
              fluidRow(
                column(4,
                      sliderInput(inputId = "turns", label = "full turns around coiling axis",  min = 0, max = 12, value = 3.5, step = 0.25, width = "100%")),
                column(2,
                      radioButtons("gl", "plot growth lines?", choices = list("yes" = 2, "no" = 1), selected = 1)),
                column(2,
                      radioButtons("ca", "plot coiling axis?", choices = list("yes" = 2, "no" = 1), selected = 2)),
                column(4,
                      sliderInput(inputId = "d", label = "Di (distance from coiling axis)",
                            min = -0.7, max = 0.7, value = -0.01, step = 0.01, width = '100%'))
              )
                     ),

            tabPanel("Background",
                     fluidRow(style = "height:10px; background-color:#0073b7;"),
                     fluidRow(style = "height:20px;"),
                     fluidRow(
                       column(8,
                       h2("Raup's Shell Coiling Equations", style = "font-size:33px;"),
                       #####
                       p("Shell growth in mollusks (snails, clams, and relatives) and brachiopods can be modeled with the logarithmic spiral, where a 'generating curve' (what ultimately becomes the commissure)
                       rotates about a coiling axis (the black line in the animation to the right). The general shell form of", strong("any"), "mollusk or brachiopod species can be created by modifying the following parameters:", style = "font-size:18px;"),
                       p(strong("S")," - the shape of the generating curve", style = "font-size:18px;"),
                       p(strong("W")," - the rate at which the size of the generating curve expands", style = "font-size:18px;"),
                       p(strong("T")," - the rate of translation of the generating curve along the coiling axis", style = "font-size:18px;"),
                       p(strong("D")," - the distance between the generating curve and the coiling axis", style = "font-size:18px;"),
                       p("The animation to the right shows the growth of a generic gastropod shell, where cooler colors correspond to older parts of the shell (that were grown when the animal was young) and warmer colors correspond to younger parts of the shell.", style = "font-size:18px;")
                       ),
                       #####
                       column(4, img(src='Shell_coiling_GIF.gif', align = "center", height = "350px"))
                     ),
                     fluidRow(style = "height:20px;"),
                     fluidRow(style = "height:10px; background-color:#0073b7;"),
                     fluidRow(style = "height:20px;"),
                     # fluidRow(
                     #   column(4.75, img(src="rings_spragg.jpg",align="left", height = "325px", width = "auto")),
                     #   column(7.25,
                     #          p("If you've ever picked up a seashell, you probably noticed the concentric rings around the exterior of the shell. These are called growth lines and they represent growth-stages in the animal's life or periods of environmental or physiological stress", style = "font-size:18px;"))
                     # ),
                     fluidRow(
                       column(8,
                       h2("S", style = "font-size:33px;"),
                       p("The S parameter controls the shape of the generating curve/aperture. Originally, Raup defined the parameter such that S = 1 is a circle, S > 1 defines apertures more eccentric perpendicular to the coiling axis, and S < 1 defines apertures more eccentric parellel to the coiling axis.
                         But, as Raup noted, there are additional ways to describe the shape of a generating curve. Here, I subset Raup's initial S parameter into a parameter controlling the eccentricity of an ellipse and another controlling the rotation of that ellipse. These two sub-parameters of S describe variation in
                         commissure shape more fully than Raup's original scheme, but is still quite idealized. Incorporating non-elliptical shapes, 'tilt' of the aperture (which bivalves use to accomodate potential overlapping of their shells), and ornamentation would produce more realistic S parameters.", style = "font-size:18px;")),
                       column(4, img(src='S_param.svg', align = "center", height = "350px"))
                     ),
                     fluidRow(style = "height:20px;"),
                     fluidRow(style = "height:10px; background-color:#0073b7;"),
                     fluidRow(style = "height:20px;"),

                     fluidRow(
                       column(8,
                       h2("W", style = "font-size:33px;"),
                       p("The W parameter, whorl expansion rate, determines the rate at which the size of the generating curve grows during shell growth, where larger W values indicating more rapidly expanding generating curves. The user is modifying the exponent of this term (W = 10^input).
                          To the right are two shells with identical S, T, and D parameters, but different W parameters.
                          In the gray shell, W = 10^0.3, but in the red shell W = 10^0.33. ", style = "font-size:18px;")),
                       column(4, img(src='w_gif.gif', align = "center", height = "250px"))
                     ),
                     fluidRow(style = "height:20px;"),
                     fluidRow(style = "height:10px; background-color:#0073b7;"),
                     fluidRow(style = "height:20px;"),

                     fluidRow(
                       column(8,
                       h2("T", style = "font-size:33px;"),
                       p("The T parameter, translation rate, determines the distance that the generating curve is translated along the coiling axis per rotation step. Animals with larger T values will be 'taller'.
                         Ammonites characteristically have T values equally 0, and gastropods nearly always have non-zero T values. Assigning a negative value to T will produce a shell coiling in the opposite direction along the coiling axis.
                         In the example to the right, T = 2.5 in the gray shell and T = 5.0 in the red shell, all else is held constant.", style = "font-size:18px;")),
                       column(4, img(src='t_gif.gif', align = "center", height = "250px"))
                     ),
                     fluidRow(style = "height:20px;"),
                     fluidRow(style = "height:10px; background-color:#0073b7;"),
                     fluidRow(style = "height:20px;"),

                     fluidRow(
                       column(6,
                       h2("D", style = "font-size:33px;"),
                       p("The final parameter, D, describes the distance of the generating curve from the coiling axis, where D = 0 means the generating curve is touching the coiling axis, D > 0 means the generating curve is farther away from the coiling axis, and in cases where D < 0, the generating curve overlaps with the coiling axis.
                         In the example shown to the right, D = 0 in both gray shells, in the left animation D of the red shell = 0.125, and in the right animation D of the red shell = -0.125.", style = "font-size:18px;")),
                       column(3, img(src='di_gif.gif', align = "center", height = "250px")),
                       column(3, img(src='di2_gif.gif', align = "center", height = "250px"))
                     ),
                     fluidRow(style = "height:20px;"),
                     fluidRow(style = "height:10px; background-color:#0073b7;"),
                     fluidRow(style = "height:20px;"),

                     fluidRow(
                       column(12,
                       h2("Relevant References", style = "font-size:33px;"),
                       p(tags$a(href="https://en.wikipedia.org/wiki/On_Growth_and_Form",
                                "Thompson 1917 'On Growth and Form'"), style = "font-size:18px;"),
                       p(tags$a(href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC221494/",
                                "Raup 1961 'The Geometry of Coiling in Gastropods', Proceedings of the National Academy of Science"), style = "font-size:18px;"),
                       p(tags$a(href="DOI: 10.1126/science.138.3537.150",
                                "Raup 1962 'Computer as Aid in Describing Form in Gastropod Shells', Science"), style = "font-size:18px;"),
                       p(tags$a(href="DOI: 10.1126/science.147.3663.1294",
                                "Raup & Michelson 1965 'Theoretical Morphology of the Coiled Shell', Science"), style = "font-size:18px;"),
                       p(tags$a(href="https://www.jstor.org/stable/1301992",
                                "Raup 1966 'Geometric Analysis of Shell Coiling: General Problems', Journal of Paleontology"), style = "font-size:18px;"),
                       p(tags$a(href="https://doi.org/10.1017/scs.2017.9",
                                "Polly & Motz 2016 'Patterns and Processes in Morphospace: Geometric Morphometrics of Three-Dimensional Objects', The Paleontological Society Papers"), style = "font-size:18px;"),
                       p(tags$a(href="https://doi.org/10.1111/brv.12276",
                                "Gerber 2016 'The Geometry of Morphospaces: Lessons from the Classic Raup Shell Coiling Model', Biological Reviews"), style = "font-size:18px;"))
                     ),


                     ),
            tabPanel("Help",
                     fluidRow(
                      column(1,""),
                       column(10,
                          h3("Please contact Daniel Rhoda (drhoda6@gmail.com) for feedback, suggestions, notice of errors, etc. ", align = "center"),
                          br(),
                          p(strong("Sinistral vs. Dextral"),"  -  This button controls the chirality of the shell that's produced. In other words, it determines whether your shell coils clockwise or counter-clockwise, think of it as the 'handedness' of your shell.
                            Fun fact: over 90% of gastropod species are dextral, but there", em("are"), "species that exclusively coil sinistral, and others that coil both ways.
                            Less fun fact: in the code for this app, sinistral shells are created simply by 'uncoiling' the shell by making W = 1/W and then rescaling.", style = "font-size:18px;", align = "center"),
                          br(),
                          p(strong("Full turns around coiling axis"),"  -  This parameter determines how many times the generating curve/aperture fully rotates around the coilng axis. If you have a high W parameter set, changing the amount of turns may look inconsequential, because all of the intial turns are very small compared to the relatively larger final turns.", style = "font-size:18px;", align = "center"),
                          br(),
                          p(strong("Plot growth lines?"),"  -  Checking 'yes' to this will plot the growth lines that were produced by Raup's equations given your input parameters, colored by ontogenetic age. Cooler colors are older parts of the shell, deposited earlier in its life, and warmer colors are younger parts of the shell. High W values may make the cool colors difficult to see.", style = "font-size:18px;", align = "center"),
                          br(),
                          p(strong("Plot coiling axis?"),"  -  Whether or not you want to view the coiling axis that the generative curve rotates about. Visualizing this is immensely helpful for understanding Raup's equations.", style = "font-size:18px;", align = "center"),
                          br(),
                          p(strong("Presets & random shells"),"  -  There are three preset shells available to the user by clicking the buttons on the sidebar, a gastropod, a pelycopod, and an ammonoid. There is also the option to generate 'random' gastropod, pelycopod, or ammonoid shells by drawing parameter values from a uniform distribution approximately corresponding to the ranges from", tags$a(href="https://www.jstor.org/stable/1301992","Raup's 1966 'Geometric Analysis of Shell Coiling' paper in the Journal of Paleontology."), style = "font-size:18px;", align = "center")
                        ),
  #                    column(width=1)
                     )
      ))
    ), # tabs





#   , fluidRow(downloadButton("downloadShell", "Export your shell",  style = "width:100%;"))

  )#dashboard body


)



server <- (function(input, output, session){

  observeEvent(input$clam,{
    updateSliderInput(session,'s1',value = 0.3)
    updateSliderInput(session,'s2',value = 90)
#    updateSliderInput(session,'tilt',value = 0)
    updateSliderInput(session,'w',value = 2.3)
    updateSliderInput(session,'t',value = 0)
    updateSliderInput(session,'d',value = 0.02)
#    updateSliderInput(session,'degrees',value = 3)
    updateSliderInput(session,'turns',value = 1.5)
  })
  observeEvent(input$snail,{
    updateSliderInput(session,'s1',value = 0.3)
    updateSliderInput(session,'s2',value = 0)
#    updateSliderInput(session,'tilt',value = 0)
    updateSliderInput(session,'w',value = 0.3)
    updateSliderInput(session,'t',value = 2.5)
    updateSliderInput(session,'d',value = -0.05)
#    updateSliderInput(session,'degrees',value = 3)
    updateSliderInput(session,'turns',value = 3.5)
  })
  observeEvent(input$ammonite,{
    updateSliderInput(session,'s1',value = 0.3)
    updateSliderInput(session,'s2',value = 7)
#    updateSliderInput(session,'tilt',value = 0)
    updateSliderInput(session,'w',value = 0.4)
    updateSliderInput(session,'t',value = 0)
    updateSliderInput(session,'d',value = 0.63)
#    updateSliderInput(session,'degrees',value = 3)
    updateSliderInput(session,'turns',value = 7.5)
  })

  # the random buttons
    observeEvent(input$clam2,{
    updateSliderInput(session,'s1',value = runif(1,0,1))
    updateSliderInput(session,'s2',value = runif(1,-180,180))
    updateSliderInput(session,'w',value = runif(1, min = 1, max = 5))
    updateSliderInput(session,'t',value = runif(1,0,1))
    updateSliderInput(session,'d',value = runif(1,0,0.2))
    updateSliderInput(session,'turns',value = runif(1,1.5,4))
  })
  observeEvent(input$snail2,{
    updateSliderInput(session,'s1',value = runif(1,0,1))
    updateSliderInput(session,'s2',value = runif(1,-180,180))
    updateSliderInput(session,'w',value = runif(1,0.1,1.1))
    updateSliderInput(session,'t',value = runif(1,0.5,3.5))
    updateSliderInput(session,'d',value = runif(1,-0.1,0.1))
#    updateSliderInput(session,'d',value = runif(1,0,0.33))
    updateSliderInput(session,'turns',value = runif(1,3.5,7.5))
  })
  observeEvent(input$ammonite2,{
    updateSliderInput(session,'s1',value = runif(1,0,1))
    updateSliderInput(session,'s2',value = 0)
    updateSliderInput(session,'w',value = runif(1,0.1,0.5))
    updateSliderInput(session,'t',value = 0)
    updateSliderInput(session,'d',value = runif(1,0,0.65))
    updateSliderInput(session,'turns',value = runif(1,3,8))
  })




#  observe(session$setCurrentTheme(
#    if(input$dark_mode)dark else light))


input.shell <- reactive({
      commissure <- ellipse(c(0,0),sigma=matrix(c(1,input$s1,input$s1,1),nrow=2,ncol=2),draw=F,npoints=26)[-26,]
      commissure <- Rotation(commissure,(input$s2-45)*(pi/180)) # -45 because modifying 'eccentricity' is done by increasing r12 of a 2d covariance matrix, which consequentially makes the eccentric ellipses point in the +/+ or -/- direction
      s <- matrix(0,nrow=25,ncol=3)
      s[,c(1,3)] <- commissure

      shell1 <- RaupCoil(s = s, w = 10^input$w, t = input$t, di = input$d, degrees = 3,
                    turns = input$turns, sinistral = input$uncoil)
      shell1 <- rescale.shell(shell1)
      shell1
})


output$plot <- renderRglwidget({

      shell1 <- input.shell()
      shell2 <- ResampleShell(shell1, 100)

    try(close3d())
    rgl.open(useNULL=T)

      comprmesh <- make.mesh.from.shell(shell2)
      shade3d(comprmesh, col = "lightgray")

    if(input$gl == 2){PlotRaupShellPoints(shell = shell1, pal = col.pal)}
    if(input$ca == 2){
      L <- max(shell1[,3,])
      lines3d(matrix(c(0,0,0,0,L+(L/3),0-(L/3)),2), lwd = 3, col = "black")
      }
    rglwidget()
    })

#     output$downloadShell <- downloadHandler(
#       filename = function() {
#         paste("Your_shell_", Sys.time(), ".ply", sep="")
#       },
#       content = function(file) {
# #       mesh2ply(make.mesh.from.shell(ResampleShell(input.shell(), 100)), filename = file)
#        vcgPlyWrite({make.mesh.from.shell(ResampleShell(shell1, 100))}, filename = file)
# #       writePLY({make.mesh.from.shell(ResampleShell(input.shell(), 100))}, format = "ascii")
# #        mesh2ply(make.mesh.from.shell(ResampleShell(input.shell(), 100)), file)
#
#       },
#       contentType = "mesh3d"
#     )

})
shinyApp(ui = ui, server = server)



# to do :

# information buttons: https://stackoverflow.com/questions/61811177/how-to-make-an-infomation-button-in-shiny-dashboard
# make the color ramps customizable
# finish presets, add more - it's own page?
    # MAKE RANDOM snail/clam/ammonite...
# bivalve option...
# clean up text/label sizes, make it prettier
